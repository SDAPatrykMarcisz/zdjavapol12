=== Definicja klasy generycznej

Przyjrzyjmy siÄ™ nastÄ™pujÄ…cemu kodowi:

[source,java]
----
List<Integer> ints = Arrays.asList(1, 2, 3);
int sum = 0;
for (int n : ints) {
    sum += n;
}
System.out.println(sum);
----

Intuicyjnie wiemy Å¼e chodzi o to, Å¼e w liÅ›cie znajdujÄ… siÄ™ obiekty typu Integer.
JeÅ›li jednak spojrzymy w definicjÄ™ interfejsu List, zobaczymy:

[source,java]
----
public interface List<E> extends Collection<E>
----

w takim przypadku mÃ³wimy o liÅ›cie typu generycznego, typie E. W momencie kiedy w definicji funkcji lub klasy uÅ¼yjemy nawiasÃ³w, oznaczamy jÄ… jako generycznÄ…, to znaczy dowolnego typu ktÃ³ry zostanie wstawiony w miejsce znaku E.

przed wprowadzeniem generykÃ³w w javie 5, powyÅ¼szy przykÅ‚ad wyglÄ…daÅ‚ nastÄ™pujÄ…co:

[source,java]
----
List ints = Arrays.asList(new Integer[]{new Integer(1), new Integer(2), new Integer(3)});
int sum = 0;
for (Iterator it = ints.iterator(); it.hasNext(); ) {
    int n = ((Integer) it.next()).intValue();
    sum += n;
}
System.out.println(sum);
----

WeÅºmy pod uwagÄ™ inny przykÅ‚ad:
[source, java]
----
List<String> words = new ArrayList<String>();
words.add("Hello ");
words.add("world!");
String s = words.get(0)+words.get(1);
System.out.println(s.equals("Hello world!"));
----
oraz
[source, java]
----
List words = new ArrayList();
words.add("Hello ");
words.add("world!");
String s = ((String)words.get(0))+((String)words.get(1));
System.out.println(s.equals("Hello world!"))
----

Jak widaÄ‡ moÅ¼na uÅ¼ywaÄ‡ kolekcji bez podania typu generycznego, jednakÅ¼e przed uÅ¼yciem typu wÅ‚aÅ›ciwego dla przechowywanego obiektu potrzeba wykonaÄ‡ rzutowanie wprost, explicite. JeÅ›li przyjrzymy siÄ™ wynikowi kompilacji dwÃ³ch ostatnich blokÃ³w, zauwaÅ¼ymy Å¼e instrukcje bytecode sÄ… identyczne, a w czasie dziaÅ‚ania programu (runtime) typ jest reprezentowany przez po prostu List.
[source, java]
----
List<String> list = new ArrayList<>();
System.out.println(list.getClass().getName())
----

Aby stworzyÄ‡ klasÄ™ generycznÄ…, wzbogacamy jÄ… o _formal type parameter_, ktÃ³ry umieszczamy w ostrych nawiasach, tzw. _diamond operator_ (czyli wspomniane wczeÅ›niej E)

[source,java]
----
import java.util.Objects;

public class Crate <T> {
    private T content;

    public T emptyCrate() {
        T toReturn = content;
        content = null;
        return toReturn;
    }

    public void packCrate(T contents) {
        if(Objects.isNull(this.content)){
            this.contents = content;
        } else {
            System.err.println("cannot pack if something inside");
        }
    }
}
----

konwencja nazewnicza typÃ³w generycznych:

* E - element (to oznaczenie wykorzystywane jest najczÄ™Å›ciej we frameworku Collections)
* K - klucz
* N - liczba
* T - typ
* V - wartoÅ›Ä‡
* S, U, V - dla nastÄ™pnych typÃ³w

jednakÅ¼e nic nie stoi na przeszkodzie, by mÃ³c korzystaÄ‡ ze swoich nazw, jeÅ¼eli bÄ™dÄ… bardziej sugestywne aniÅ¼eli E,K,V itd.

typ generyczny podajemy podczas tworzenia obiektu, dziÄ™ki czemu wiadomo jakie typy majÄ… byÄ‡ uÅ¼ywane do operacji na danej klasie, jednakÅ¼e reguÅ‚y te obowiÄ…zujÄ… przed kompilacjÄ…, poniewaÅ¼ pÃ³Åºniej nastÄ™puje tzw. _type erasure_, czyli wszystkie typy generyczne zostajÄ… sprowadzone do klasy Object, wobec czego powyÅ¼sza klasa po kompilacji wyglÄ…da nastÄ™pujÄ…co:

[source,java]
----
public class Crate {
    private Object content;

    public Object emptyCrate() {
        Object toReturn = content;
        content = null;
        return toReturn;
    }

    public void packCrate(Object contents) {
        this.contents = content;
    }
}
----

Typami generycznymi mogÄ… byÄ‡ tylko typu referencyjnego (obiektowego), dlatego bardzo przydatny jest mechanizm boxingoraz unboxing typu prymitywnego na referencyjny i odwrotnie.
Przypomnijmy sobie typy prymitywne i odpowiadajÄ…ce im typy referencyjne


|===
|Primitive |Reference

|byte       |Byte
|short      |Short
|int        |Integer
|long       |Long
|float      |Float
|double     |Double
|boolean    |Boolean
|char       |Character
|===

PoniÅ¼sze zapisy sÄ… sobie rÃ³wne
[source, java]
----
List<Integer> ints = new ArrayList<Integer>();
ints.add(1);
int n = ints.get(0);
----
[source, java]
----
List<Integer> ints = new ArrayList<Integer>();
ints.add(Integer.valueOf(1));
int n = ints.get(0).intValue();
----

Co wiÄ™cej, parametrami typu generycznego mogÄ… byÄ‡ inne typy generyczne! np.
[source, java]
----
List<List<String>> listOfListOfStrings = new ArrayList<>();
ArrayList<String> listInsideOfList = new ArrayList<>();
listInsideOfList.add("first!");
listOfListOfStrings.add(listInsideOfList);

System.out.println(listOfListOfStrings.get(0).get(0)); //<-- "first!
----

==== tworzenie obiektu generycznego:

[source,java]
----
Crate<Zebra> zebraCrate = new Crate<>(); //lub new Crate<Zebra>();
zebraCrate.packCrate(new Zebra());
Zebra zebra = emptyCrate();
----

=== Ograniczanie deklarowanego typu generycznego

Przy pracy z typami generycznymi mamy dostÄ™p rÃ³wnieÅ¼ do mechanizmu ograniczenia typu generycznego:

[source,java]
----

abstract class Animal{
    abstract void roar();
}

class AnimalWrapper<T extends Animal>{

    T animal;

    public AnimalWrapper(T animal) {
        this.animal = animal;
    }

    public void animalRoar(){
        animal.roar();
    }

}

----

jeÅ›li wiemy Å¼e moÅ¼emy umieÅ›ciÄ‡ jako typ generyczny wyÅ‚Ä…cznie klasy ktÃ³re dziedziczÄ… po klasie Animalâ€¦ bÄ™dziemy mieÄ‡ pewnoÅ›Ä‡ Å¼e majÄ… dostÄ™p do tych metod ktÃ³re sÄ… tam zdefiniowane ğŸ˜‰.

Realizujemy to poprzez dodanie sÅ‚Ã³wka extends w typie generycznym.

Teraz obiekty typu T maja dostÄ™p do metod klasy Animal (domyÅ›lnie tylko do metod klasy Object)

=== generyczne interfejsy

Podobnie jak w przypadku klas, rÃ³wnieÅ¼ interfejsy mogÄ… byÄ‡ typu generycznego

[source,java]
----
public interface Shippable < T > {
    void ship(T t);
}
----

wÃ³wczas, gdy chcemy zaimplementowaÄ‡ dany interfejs, podczas wykonywania instrukcji implements podajemy docelowy typ, np.

[source,java]
----
class ShippableZebraCrate implements Shippable <Zebra> {

    public void ship(Zebra t){
        ...
    }
}
----

uÅ¼ycie:

[source,java]
----
public static void main(String[] args){
  ShippableZebraCrate zebraCrate = new ShippableZebraCrate();
  zebraCrate.ship(new Zebra()); //nie przyjmie niczego poza zebrÄ…... lub obiektem dziedziczÄ…cym po Zebra
}

----

lub zachowaÄ‡ generycznoÅ›Ä‡ tego rozwiÄ…zania, wiÄ…Å¼Ä…c to z typem generycznym powiÄ…zanym z klasÄ… implementujÄ…cÄ…:

[source,java]
----
class ShippableGenericCrate <U> implements Shippable <U> {

    public void ship(U t){
        ...
    }
}
----

uÅ¼ycie:

[source,java]
----
public static void main(String[] args){
  ShippableGenericCrate<Zebra> zebraCrate = new ShippableGenericCrate();
  zebraCrate.ship(new Zebra());
}
----

=== Kiedy uÅ¼ywamy generykÃ³w ?

np. jeÅ›li nie chcemy siÄ™ martwiÄ‡ czy ktoÅ› nie wrzuciÅ‚ do listy czegoÅ› czego siÄ™ nie spodziewamy.

tak wyglÄ…da sytuacja w ktÃ³rej korzystamy z ogÃ³lnego typu List (de facto List<Object>) - tutaj trzeba siÄ™ martwiÄ‡ :D

[source,java]
----

static void printNames(List list) {
    for (int i = 0; i < list.size(); i++) {
        String name = (String) list.get(i); // class cast exception here
        System.out.println(name);
    }
}

public static void main(String[] args) {
    List names = new ArrayList();
    names.add(new StringBuilder("Webby"));
    printNames(names);
}
----

natomiast jeÅ›li uÅ¼yjemy typÃ³w generycznych...

[source,java]
----
List<String> names = new ArrayList<String>();
names.add(new StringBuilder("Webby")); // DOES NOT COMPILE
----

=== Czy w danej klasie moÅ¼e byÄ‡ tylko jeden typ generyczny ?

Nie, klasa moÅ¼e zawieraÄ‡ 0 lub wiÄ™cej typÃ³w generycznych :)

[source,java]
----
public class TwoPartsCrate<T, U> {
    private T first;
    private U second;

    public SizeLimitedCrate(T firstContent, U secondContent) {
        this.first = firstContent;
        this.second = secondContent;
    }
}
----

=== Metody generyczne

moÅ¼liwe jest utworzenie metody typu generycznego (nie musimy deklarowaÄ‡ wÃ³wczas poziomu generycznego na poziomie klasy)

[source,java]
----
public static <T> Crate<T> ship(T t) {
    System.out.println("Preparing " + t);
    return new Crate<T>();
}
----

==== przykÅ‚ady metod:

[source,java]
----
public static <T> void sink(T t) { }
public static <T> T identity(T t) { return t; }
public static T noGood(T t) { return t; } // DOES NOT COMPILE, brak definicji typu w ramach <>
----

==== wywoÅ‚ania metod generycznych

Metody generyczne moÅ¼emy wywoÅ‚aÄ‡ tak jak normalne metody, kompilator moÅ¼e siÄ™ wÃ³wczas domyÅ›liÄ‡ zwracanego typu np. na podstawie parametru (jeÅ›li argument typu generycznego znajduje siÄ™ na liÅ›cie parametrÃ³w).
MoÅ¼emy rÃ³wnieÅ¼ podaÄ‡ typ wprost, umieszczajÄ…c go w nawiasach klamrowych *przed* wywoÅ‚aniem funkcji, np. dla metody ship oba poniÅ¼sze wywoÅ‚ania sÄ… poprawne:

[source,java]
----
public class Box {

   public static <T> T ship(T input){
       return input;
   }

    public static void main(String[] args) {
        String stringBox = Box.<String>ship("package");
        String[] stringArrayBox = Box.<String[]>ship(args);

        String stringBox2 = Box.ship("package");
        String[] stringArayBox2 = Box.ship(args);
    }
}
----

===== PrzykÅ‚ad metody wykorzystujÄ…cej ograniczenie typÃ³w:

funkcja konwertujÄ…ca na inny typ:

[source,java]
----
public static <T, R extends T> T convert(Class<T> clazz, R toConvert){
    return clazz.cast(toConvert);
}

Number number = convert(Number.class, 5);
System.out.println(number); // ïƒ  5
----

=== Czego typy generyczne nie potrafiÄ… ?

WiÄ™kszoÅ›Ä‡ ograniczeÅ„ dotyczÄ…cych typÃ³w generycznych (type parameter), wynika z ich wÅ‚aÅ›ciwoÅ›ci _type erasure_, tj. wymazywania typu w trakcie kompilacji, i zastÄ™powanie go typem Object.
W zwiÄ…zku z tym:

* nie moÅ¼na wywoÅ‚ywaÄ‡ konstruktora - wynika to z faktu, Å¼e w czasie uruchomienia programu (_runtime_), jest on zamieniony na konstruktor klasy Object (new Object()), a co za tym idzie jedyny konstruktor jest bezargumentowy, jeÅ›li klasa bÄ™dzie posiadaÄ‡ inny konstruktor, konstrukcja nie zadziaÅ‚a
* tworzyÄ‡ tablicy typu T[] - w przeciwieÅ„stwie do typÃ³w generycznych, tablica przechowuje informacjÄ™ na temat przechowywanego typu w trakcie dziaÅ‚ania programu, a w momencie wymazywania typÃ³w po kompilacji.
Jako Å¼e nie wiemy jakiego typu jest T po kompilacji, nie moÅ¼emy stworzyÄ‡ jej instancji. (dyskusja na ten temat tutaj: https://stackoverflow.com/questions/2927391/whats-the-reason-i-cant-create-generic-array-types-in-java) sÄ… obejÅ›cia, np.

[source,java]
----
T t; //zakÅ‚adajÄ…c Å¼e obiekt jest w jakiÅ› sposÃ³b zainicjalizowany lub przekazany jako parametr
int length = 5; //przykladowo, rozwniez jako np. parametr
T[] ts = (T[]) Array.newInstance(t.getClass(), length); //rozwiazanie wykorzystujace mechanizm refleksji
----

[source,java]
----
public class Box<S> {

    S[] ts;

    public Box(S first, S ... objects){
        // this.ts = new S[objects.length+1]; //tak nie mozemy
        this.ts = (S[]) Array.newInstance(first.getClass(), objects.length > 0 ? objects.length+1 : 1);
        //rozwiazanie wykorzystujace mechanizm refleksji, uwaga ze strony kompilatora
        ts[0] = first;
        for(int i=0; i<objects.length; i++){
            ts[i+1] = objects[i];
        }
    }

    public void printAll(){
        for (S t : ts) {
            System.out.println(t);
        }
    }

    public static void main(String[] args) {
        Box<String> box = new Box<>("first", "second", "third", "fourth");
        box.printAll();
    }
}
----

* wykorzystywaÄ‡ mechanizmu instanceof - skoro typ jest wymazywany, to List<String> i List<Integer> sÄ… z punktu widzenia programu identyczne (obj instanceof Object) <-- zawsze prawda
* uÅ¼ywaÄ‡ typÃ³w prymitywnych jako typu generycznego - co nie jest duÅ¼ym problemem, biorÄ…c pod uwagÄ™ mechanizm autoboxingu typÃ³w prymitywnych
* tworzyÄ‡ list obiektÃ³w typu genertycznego(np. new List<String>[3] jest niepoprawne), dopÃ³ki nie uÅ¼yjemy unbounded wildcard (o tym za chwilÄ™, new List<?>[3] jest poprawne)
* definiowania zmiennych statycznych jako pÃ³l klasy - niemoÅ¼liwe poniewaÅ¼ sÄ… one powiÄ…zane z klasÄ… a nie konkretnym obiektem, a okreÅ›lenie typu zmiennej moÅ¼liwe jest podczas tworzenia obiektu

ostatni punkt; gdyby byÅ‚o moÅ¼liwe

[source,java]
----
public class MobileDevice<T> {
    private static T os;
}
----

wÃ³wczas jakiego typu byÅ‚aby zmienna os:

[source,java]
----
MobileDevice<Smartphone> phone = new MobileDevice<>();
MobileDevice<Pager> pager = new MobileDevice<>();
MobileDevice<TabletPC> pc = new MobileDevice<>();

MobileDevice.os; // ??? jaki typ ? pewnie najlepszy bylby Object ;)
----

==== niebezpieczny (acz kompilowalny!) kod

[source,java]
----
public class LegacyUnicorns {
    public static void main(String[] args) {
        java.util.List<Unicorn> unicorns = new java.util.ArrayList<>();
        addUnicorn(unicorns);
        Unicorn unicorn = unicorns.get(0); // ClassCastException
    }

    private static void addUnicorn(List unicorn) {
        unicorn.add(new Dragon());
    }
}
----

=== Granice (bounds)

Typy generyczne oprÃ³cz definiowania symboli oznaczajÄ…cych poszczegÃ³lne typy, posiadajÄ… rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ okreÅ›lenia zakresÃ³w typÃ³w.
_Wildcard_, to tzw. maska / zaÅ›lepka, okreÅ›lajÄ…ca wyraÅ¼enie ograniczajÄ…ce danÄ… wartoÅ›Ä‡

_Bounded parameter type_ to specjalny rodzaj generyka.

_Wildcard generic type_, to nieznany rodzaj typu generycznego, okreÅ›lany przez typ < _?_ >.
UÅ¼ywamy go wÃ³wczas, kiedy kaÅ¼dy typ jest dla nas "OK"

|===
| Typ ograniczenia                              | SkÅ‚adnia          | PrzykÅ‚ad
| Unbounded Wildcard (dowolny typ)              | ?                 | List<?> l = new ArrayList<String>();
| Wildcard ograniczona odgÃ³rnie (upper bound)   | ? extends type    | List<? extends Exception> l = new ArrayList<RuntimeException>();
| Wildcard ograniczona oddolnie (lower bound)   | ? super type      | List<? super Exception> l = new ArrayList<Object>();
|===

Granice dotyczÄ… tylko typÃ³w referencyjnych, a nie samych obiektÃ³w!

=== Unbounded Wildcards

ZwrÃ³Ä‡my uwagÄ™ na nastÄ™pujÄ…cy kod:

[source,java]
----
    public static void printList(List<Object> list) {
        for (Object x : list){
            System.out.println(x);
        }
    }

    public static void main(String[] args) {
        List<String> keywords = new ArrayList<>();
        keywords.add("java");
        printList(keywords); // DOES NOT COMPILE
    }
----

co tu jest nie tak ?
PrzecieÅ¼ String jest podklasÄ… Object, wiÄ™c jeÅ›li metoda przyjmuje List typu sparametryzowanego Object, to List<String> nie speÅ‚nia tego warunku ?
No niestety nie... nie moÅ¼emy przypisaÄ‡ listy typu List<String> do referencji typu List<Object>.
Tak, to brzmi nielogicznie.
WiÄ™c dlaczego ?
SpÃ³jrzmy na inny kod:

[source,java]
----
List<Integer> numbers = new ArrayList<>();
numbers.add(new Integer(42));

List<Object> objects = numbers; // DOES NOT COMPILE
objects.add("forty two");

System.out.println(numbers.get(1));
----

Jak widzimy przypisanie listy List<Integer> do typu List<Object> mogÅ‚oby siÄ™ Åºle dla nas skoÅ„czyÄ‡.
Kompilator obiecaÅ‚ nam Å¼e do listy numbers bÄ™dziemy mogli dodawaÄ‡ tylko obiekty typu Integer.
GdybyÅ›my przypisali tÄ… listÄ™ do referencji typu List<Object> wÃ³wczas moglibyÅ›my dodawaÄ‡ dowolne obiekty dziedziczÄ…ce po Object, czyli obietnica kompilatora poszÅ‚a by... :) Jak wiÄ™c moÅ¼emy rozwiÄ…zaÄ‡ nasz problem ?
MoÅ¼emy powiedzieÄ‡ Å¼e to czego tak naprawdÄ™ potrzebujemy, to nie lista obiektÃ³w typu Object, a raczej lista obiektÃ³w typu dowolnego List<?>.
WÃ³wczas kaÅ¼dy element bÄ™dzie traktowany jak Object:

[source,java]
----
public static void main(String[] args) {
    List<String> keywords = new ArrayList<>();
    keywords.add("java");
    printList(keywords);

    List<Integer> integers = new ArrayList<>();
    integers.add(40);
    printList(integers);
}

public static void printList(List<?> list) {
    for (Object x: list){
        System.out.println(x);
    }
    //list.add("pies"); tej operacji nie wykonamy, ogranicza nas wildcard ?
}

public static void printListOfObjects(List<Object> list) { //przypominam, referencja to "sposob patrzenia na obiekt"
    for (Object x: list){
        System.out.println(x);
    }
}
----

=== Upper-Bounded Wildcards

Jak ustaliÅ›my wyÅ¼ej, poniÅ¼szy przykÅ‚ad siÄ™ nie skompiluje:

[source,java]
----
ArrayList<Number> list = new ArrayList<Integer>(); // DOES NOT COMPILE
----

Jako Å¼e byÅ‚oby to sytuacjÄ… naruszenia kontraktu, w ktÃ³rym do listy deklarujÄ…cej trzymanie obiektÃ³w typu Integer, moÅ¼na by dodaÄ‡ np. obiekt typu Double

Zamiast tego, musimy uÅ¼yÄ‡ nastÄ™pujÄ…cej kontrukcji:

[source,java]
----
List<? extends Number> list = new ArrayList<Integer>();
----

Oznacza to, Å¼e do referencji List<? extends Number> moÅ¼emy przypisaÄ‡ dowolnÄ… kolekcje, ktÃ³rej elementy bÄ™dÄ… typu dziedziczÄ…cego po Number.
MoÅ¼emy to zapisaÄ‡ rÃ³wnieÅ¼ nastÄ™pujÄ…co:

[source,java]
----
List<Number> list = new ArrayList<Number>();
----

stracimy jednak wÃ³wczas moÅ¼liwoÅ›Ä‡ umieszczania w tej liÅ›cie wyÅ‚Ä…cznie obiektÃ³w typu Integer (a moÅ¼e nam na tym zaleÅ¼eÄ‡).

MajÄ…c do dyspozycji typ List<? extends Number> moÅ¼emy go uÅ¼yÄ‡ w definicji metody, sumujÄ…cej wartoÅ›ci wszystkich obiektÃ³w typÃ³w liczbowych (typÃ³w dziedziczÄ…cych po Number), tj.
niezaleÅ¼nie czy przekaÅ¼emy listÄ™ typu List<Integer>, List<Double> czy nawet List<Number>, program bÄ™dzie dziaÅ‚aÄ‡ poprawnie:

[source,java]
----
public static long total(List<? extends Number> list) {
    long count = 0;
    for (Number number: list)
        count += number.longValue();
    return count;
}
----

na powyÅ¼szy kod nadal dziaÅ‚a zasada _type erasure_, w zwiÄ…zku z tym gdybyÅ›my chcieli uzyskaÄ‡ tÄ… funkcjonalnoÅ›Ä‡ bez typÃ³w generycznych, wyglÄ…daÅ‚oby to nastÄ™pujÄ…co:

[source,java]
----
public static long total(List list) {
    long count = 0;
    for (Object obj: list) {
        Number number = (Number) obj;
        count += number.longValue();
    }
    return count;
}
----

==== it's a trap!

W sytuacji gdy uÅ¼ywamy referencji typu generycznego uÅ¼ywajÄ…cego _unbounded wildcard_ lub _upper_bound_, obiekty powiÄ…zane z tym typem referencji stajÄ… siÄ™ automatycznie praktycznie niemodyfikowalne (tzw. *immutable*).
WÅ‚aÅ›ciwoÅ›Ä‡ ta oznacza, Å¼e obiekt nie moÅ¼e byÄ‡ modyfikowany (no akurat w tym przypadku moÅ¼na usuwaÄ‡, ale np. dodawaÄ‡ juÅ¼ nie).

[source,java]
----
abstract class Bird{};
class Hawk extends Bird {};
class Duck extends Bird {};

public static void main(String args[]){
    List<? extends Bird> birds = new ArrayList<Bird>(); //OK
    birds.add(new Hawk()); //nie kompiluje sie!
    birds.add(new Duck()); //nie kompiluje sie!
}
----

Dlaczego ?

z racji Å¼e dziaÅ‚amy na typie referencji, czyli List<? extends Bird>, nie wiemy czy lista bÄ™dzie typu Hawk, Duck czy jeszcze innego typu ktÃ³ry jeszcze nie powstaÅ‚.

W pierwszym przypadku - `birds.add(new Hawk())` - nie moÅ¼emy dodaÄ‡ obiektu typu Hawk do listy ktÃ³ra moÅ¼e byÄ‡ potencjalnie typu List<Duck>,

Analogicznie w przypadku `birds.add(new Duck())` - nie moÅ¼emy dodaÄ‡ obiektu typu Duck do listy, ktÃ³ra moÅ¼e byÄ‡ potencjalnie typu List<Hawk>

Z punktu widzenia javy, powyÅ¼sze scenariusze sÄ… jak najbardziej logiczne (âŒâ– _â– )

=== Lower-Bounded Wildcards

Zadanie jest nastÄ™pujÄ…ce: zaimplementuj metodÄ™ addCar(...), ktÃ³ra dodaje do list typu Object oraz String, obiekt typu String "car";

[source,java]
----
List <String> strings = new ArrayList <String>();
strings.add("motorbike");
List <Object> objects = new ArrayList <Object>(strings);

addCar(strings);
addCar(objects);
----

Aby rozwiÄ…zaÄ‡ ten problem, uÅ¼ywamy mechanizmu _lower bound_

[source,java]
----
public static void addSound(List<? super String> list){
    list.add("car");
}
----

Dlaczego to dziaÅ‚a ?
uÅ¼ywajÄ…c _lower bound_ mÃ³wimy javie, Å¼e parametrem metody danego typu moÅ¼e byÄ‡ lista obiektÃ³w typu String, lub kaÅ¼dej klasy bÄ™dÄ…cej nadklasÄ… typu String. (a jeÅ›li jest nadklasÄ… Stringa, to moÅ¼emy tego Stringa dodaÄ‡, bo String JEST zgodnie z zasadÄ… polimorfizmu rÃ³wnoczeÅ›nie kaÅ¼dym typem ponad nim)

==== it's a trap, part2

[source,java]
----
1: List <? super IOException > exceptions = new ArrayList <Exception>();
2: exceptions.add(new Exception()); // DOES NOT COMPILE
3: exceptions.add(new IOException());
4: exceptions.add(new FileNotFoundException());
----

DefiniujÄ…c w pierwszej linii typ List<? super IOException>, mÃ³wimy javie, Å¼e do zmiennej tego typu moÅ¼emy przypisaÄ‡ nastÄ™pujÄ…ce kolekcje: List<IOException>, List<Exception>, List<Object>.

Linia nr. 2 nie kompiluje siÄ™, poniewaÅ¼ moÅ¼e dojÅ›Ä‡ do sytuacji, w ktÃ³rej dodajemy obiekt typu Exception do listy typu List<IOException>.

Linia nr. 3 jest ok, poniewaÅ¼ niezaleÅ¼nie od typu kolekcji, IOException speÅ‚nia zasadÄ™ IS-A wzglÄ™dem typu przechowywanego w liÅ›cie (IOException instanceof IOException, IOException instanceof Exception, IOException instanceof Object)

Linia nr. 4 jest ok, mimo Å¼e ogranicznik typu mÃ³wi o nadklasie, to mimo to FileNotFoundException jako podklasa IOException, speÅ‚nia warunki IS-A podobnie do obiektu typu IOException

Ponadto, warto wspomnieÄ‡ Å¼e wildCards, mogÄ… byÄ‡ uÅ¼ywane tylko w przypadku typÃ³w referencyjnych, niemoÅ¼liwym jest nastÄ™pujÄ…ca konstrukcja, poniewaÅ¼ ostateczny typ musi byÄ‡ znany podczas tworzenia obiektu:

[source,java]
----
List <?> list6 = new ArrayList <? extends A>();
----

RÃ³wnieÅ¼ poniÅ¼szy kod jest nieprawidÅ‚owy; _wildcards_ zawsze musi byÄ‡ uÅ¼ywany w poÅ‚Ä…czeniu z -> *_?_*

[source,java]
----
<X> void method5(List <X super B> list) { } // DOES NOT COMPILE
----

==== Typy generyczne sÄ… skomplikowane (zaskakujÄ…cy wniosek, nieprawdaÅ¼ ?)

Nie zostaÅ‚y one dodane do Javy od samego poczÄ…tku.
W zwiÄ…zku z tym, Å¼e twÃ³rcy chcieli zachowaÄ‡ kompatybilnoÅ›Ä‡ wstecz istnieje wiele kruczkÃ³w, ktÃ³re nie sÄ… trywialne.